\documentclass[10pt]{beamer}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usetheme{metropolis}

\usepackage{appendixnumberbeamer}
\usepackage{pgfplots}
\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{minted}
\usepgfplotslibrary{dateplot}

\usepackage{xspace}
\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}

\usemintedstyle{emacs}

\newcommand\Fontvi{\fontsize{10}{12}\selectfont}


\title{Property-Based Testing}
% \subtitle{A modern beamer theme}
\date{\today}
\author{
  Luis Eduardo Bueso de Barrio\\
  lbueso@acm.org
}
\graphicspath{{./data/}{../resources/}}
\institute{ACM PLIG}
\titlegraphic{
  \hfill\includegraphics[height=1.5cm]{pics/logo_acm_cromo.png}
  \includegraphics[height=1.5cm]{pics/sig_plig.png}
}

\begin{document}

\nocite{*}

\maketitle

\begin{frame}{Índice}
  \setbeamertemplate{section in toc}[sections numbered]
  \tableofcontents[hideallsubsections]
\end{frame}

\section{Introducción}
% TODO

\section{Métodos de testing}
% TODO

\section{¿Qué es el Property-Based Testing?}

\begin{frame}{Definición}
  % TODO
\end{frame}

\begin{frame}{Herramientas}
  \begin{itemize}
  \item Haskell \textit{QuickCheck}.
  \item Erlang \textit{QuickCheck}.
  \item Erlang \textit{PropEr}.
  \item Scala \textit{ScalaCheck}.
  \item Python \textit{Hypothesis}.
  \item Java 8 \textit{QuickTheories}.
  \item JavaScript \textit{JSVerify}.
  \end{itemize}
\end{frame}

\begin{frame}{Herramientas}
  \begin{itemize}
  \item \textbf{Haskell \textit{QuickCheck}}.
  \item Erlang \textit{QuickCheck}.
  \item Erlang \textit{PropEr}.
  \item Scala \textit{ScalaCheck}.
  \item Python \textit{Hypothesis}.
  \item Java 8 \textit{QuickTheories}.
  \item JavaScript \textit{JSVerify}.
  \end{itemize}
\end{frame}

\section{QuickCheck}

\begin{frame}{Propiedades}
  Ejemplo:
  \inputminted{text}{data/reverse.hs}
  Propiedades:
  \inputminted{haskell}{data/reverse_prop.hs}
\end{frame}


\begin{frame}[standout]
  \Fontvi
  \inputminted{text}{data/pruebas_rev.txt}
\end{frame}

% \begin{frame}[standout]
%   %   ¡Atención!
% \end{standout}

\begin{frame}[standout]
  \Fontvi
  \inputminted{text}{data/reverse_prop_pruebas_verb.txt}
\end{frame}

\begin{frame}[standout]
  \Fontvi
  \inputminted{text}{data/reverse_prop_pruebas_verb1.txt}
\end{frame}

% \begin{frame}{Solución}
%   Tenemos 2 posibles soluciones:
%   \begin{itemize}
%   \item La más exhaustiva usar la función $polyQuickCheck$
%   \item La más sencilla, tipar nuestras propiedades:
%
%   \end{itemize}
% \end{frame}

\begin{frame}{Propiedades de funciones}
  Propiedad commutativa y asociativa del operador de composición
  \inputminted{haskell}{data/func_prop.hs}
\end{frame}

\begin{frame}[standout]
  \Fontvi
  \inputminted{text}{data/pruebas_func.txt}
\end{frame}

\begin{frame}{Condicionales}
  Operación de implicación $(==>)$ para condicionales
  Ejemplo:
  \inputminted{haskell}{data/max_prop.hs}
\end{frame}

\begin{frame}[standout]
  \Fontvi
  \inputminted{text}{data/pruebas_max_prop.txt}
\end{frame}

\begin{frame}{Monitorización}
  También podemos monitorizar datos de los tests:
  \inputminted{haskell}{data/monitor_test.hs}
\end{frame}

\begin{frame}[standout]
  \Fontvi
  \inputminted{text}{data/monitor_test_pruebas.txt}
\end{frame}

\begin{frame}{Estructuras Infinitas}
  Hay una sutil diferencia entre estas dos propiedades:
  \inputminted{haskell}{data/infinite.hs}
\end{frame}

\begin{frame}[standout]
  \Fontvi
  \inputminted{text}{data/infinite_prueba.txt}
\end{frame}

\begin{frame}{Generadores}
  Además de los generadores propios de QuickCheck se pueden
  implementar generadores propios.

  Para implementar generadores se
  utiliza la \textit{typeclass}:
  \inputminted{haskell}{data/arbitrary.hs}

  Ejemplo:
  \inputminted{haskell}{data/colours.hs}
\end{frame}

\begin{frame}[standout]
  \Fontvi
  \inputminted{text}{data/colours_prueba.txt}
\end{frame}

\begin{frame}{Generadores}
  Podemos mejorar nuestros generadores controlando, por ejemplo, la
  frecuencia con la que se generan determinados valores.

  \inputminted{haskell}{data/colours1.hs}
\end{frame}

\begin{frame}[standout]
  \Fontvi
  \inputminted{text}{data/colours1_prueba.txt}
\end{frame}

\begin{frame}{Modificadores}    %TODO
  Podemos mejorar nuestros generadores aplicándoles modificadores, que
  aportan ciertas propiedades:

  \inputminted{haskell}{data/modificadores.hs}

  Para buscar más modificadores consultar $Test.QuickCheck.Modifiers$
\end{frame}

\begin{frame}[standout]
  \Fontvi
  \inputminted{text}{data/modificadores_prueba.txt}
\end{frame}

\begin{frame}{Modificadores}    %TODO
  Con modificadores podemos conseguir que siempre se generen datos
  correctos para propiedades que requieren condiciones.

  Ejemplo:
  \inputminted{haskell}{data/modificadores2.hs}
\end{frame}

\begin{frame}[standout]
  \Fontvi
  \inputminted{text}{data/modificadores2_pruebas.txt}
\end{frame}

\section{Casos de Estudio}

\begin{frame}
  \begin{itemize}
  \item Unificación.
  \item Propiedades en circuitos.
  \item \textit{Pretty Printing}.
  \item Edison.
  \end{itemize}
\end{frame}

\appendix

\begin{frame}{Referencias}

  \bibliographystyle{acm}
  \bibliography{presentacion}

\end{frame}

\begin{frame}[standout]
  ¿Preguntas?
\end{frame}

\end{document}